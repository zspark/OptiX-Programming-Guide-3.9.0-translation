NVIDIA OptiX 射线追踪引擎

编程指南

Version 3.9

2015年2月12日

翻译目的：
进一步加强自己对OptiX的理解与记忆，翻译必然会存在理解上或者表达上的错误，一经发现，立即改正提交。

资源发布在Github：https://github.com/zspark/OptiX-Programming-Guide-3.9.0-translation.git


# 第一章 介绍
## 1.1 OptiX总揽
<<>>GPU对高纬度的并行处理非常在行，射线追踪非常符合它这一口味。然而，典型的射线追踪算法非常的参差不齐，它给与了任何人一探GPU计算本质的严重挑战。NVIDIA的OptiX射线追踪引擎与API集接受了这一挑战，并且提供了一个驾驭现在、乃至下一代来图形硬件架构的框架去整合射线追踪与交互式应用。借助OptiX与NVIDIA的CUDA架构，没有计算机图形学博士学位的开发者或者团队里的射线追踪工程师与交互式射线追踪技术的开发最终得以可行。

<<>>OptiX不是个渲染器。相反，它是个可伸缩的框架用于开发基于射线追踪的应用。OptiX引擎具有2个重要的内容：一个位于C端的API，定义了射线追踪必要的数据结构；一个基于CUDA
C++
的编程系统，可用来生成射线，射线与表面相交，反馈这些相交。这2部分提供了底层的“原始射线追踪”。这就允许应用程序使用射线追踪来开发图形图形，碰撞检测，声音传播，可见性检测等。

### 1.1.1 动机
<<>>真是因为抽线了常规射线追踪器的执行模型，OptiX才能够方便的集成射线追踪系统，分离用户编写的对象遍历，着色器派发、内存管理等算法。而且，返回系统可以承受未来GPU硬件结构的变化与SDK变化所带来的影响————与OpenGL、D3D一样为光栅化管线提供了一层抽象。
只要可行，OptiX引擎劲量避免具体射线追踪的行为，相反它提供一种执行用户提供的CUDA
C代码的机制去实现着色（包括
递归射线）、摄像机模型、甚至是颜色的呈现。总结来说的话，OptiX引擎可以用来执行Whitted风格的射线追踪、路径追踪、碰撞检测、原子映射，或者是其他基于射线追踪的算法。他被设计用来操作8个独立的或者与OpenGL、DirectX应用交互的射线追踪光栅化应用。

### 1.1.2 编程模型
<<>>OptiX的核心是个简单但是强大的对光线追踪器的抽象。这个光线追踪器利用用户提供的程序初始化光线，让光线与表面相交，给材质着色，引发新的光线（译注：比如透明物体需要在相交点再次发射光线以获取背后物体的信息）。光线携带的用户自定义数据描述了每一条射线各自的变量，比如颜色，迭代深度，重要程度，或者其它的一些属性。开发者利用基于CUDA
C提供的函数为这些属性提供具体的功能。因为光线追踪是个固有的递归算法，OptiX允许用户递归新的射线，内部执行机制管理着所有的递归堆栈的细节。OptiX提供了动态函数派发与高端的变量继承机制，让光线追踪系统能够被普遍与紧凑的编写。

